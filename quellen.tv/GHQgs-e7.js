import{r as C,q as yt,s as vt,k as tt,P as J,u as rt,v as bt}from"./CYM2abHa.js";const xt="ENTRIES",ct="KEYS",ut="VALUES",_="";class R{constructor(t,e){const s=t._tree,i=Array.from(s.keys());this.set=t,this._type=e,this._path=i.length>0?[{node:s,keys:i}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:e}=F(this._path);if(F(e)===_)return{done:!1,value:this.result()};const s=t.get(F(e));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=F(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>F(t)).filter(t=>t!==_).join("")}value(){return F(this._path).node.get(_)}result(){switch(this._type){case ut:return this.value();case ct:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const F=n=>n[n.length-1],Et=(n,t,e)=>{const s=new Map;if(t===void 0)return s;const i=t.length+1,o=i+e,r=new Uint8Array(o*i).fill(e+1);for(let c=0;c<i;++c)r[c]=c;for(let c=1;c<o;++c)r[c*i]=c;return dt(n,t,e,s,r,1,i,""),s},dt=(n,t,e,s,i,o,r,c)=>{const u=o*r;t:for(const d of n.keys())if(d===_){const a=i[u-1];a<=e&&s.set(c,[n.get(d),a])}else{let a=o;for(let l=0;l<d.length;++l,++a){const h=d[l],m=r*a,g=m-r;let f=i[m];const p=Math.max(0,a-e-1),y=Math.min(r-1,a+e);for(let w=p;w<y;++w){const A=h!==t[w],D=i[g+w]+ +A,M=i[g+w+1]+1,E=i[m+w]+1,L=i[m+w+1]=Math.min(D,M,E);L<f&&(f=L)}if(f>e)continue t}dt(n.get(d),t,e,s,i,a,r,c+d)}};class b{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,s]=O(this._tree,t.slice(this._prefix.length));if(e===void 0){const[i,o]=H(s);for(const r of i.keys())if(r!==_&&r.startsWith(o)){const c=new Map;return c.set(r.slice(o.length),i.get(r)),new b(c,t)}}return new b(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,zt(this._tree,t)}entries(){return new R(this,xt)}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return Et(this._tree,t,e)}get(t){const e=W(this._tree,t);return e!==void 0?e.get(_):void 0}has(t){const e=W(this._tree,t);return e!==void 0&&e.has(_)}keys(){return new R(this,ct)}set(t,e){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,$(this._tree,t).set(_,e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=$(this._tree,t);return s.set(_,e(s.get(_))),this}fetch(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=$(this._tree,t);let i=s.get(_);return i===void 0&&s.set(_,i=e()),i}values(){return new R(this,ut)}[Symbol.iterator](){return this.entries()}static from(t){const e=new b;for(const[s,i]of t)e.set(s,i);return e}static fromObject(t){return b.from(Object.entries(t))}}const O=(n,t,e=[])=>{if(t.length===0||n==null)return[n,e];for(const s of n.keys())if(s!==_&&t.startsWith(s))return e.push([n,s]),O(n.get(s),t.slice(s.length),e);return e.push([n,t]),O(void 0,"",e)},W=(n,t)=>{if(t.length===0||n==null)return n;for(const e of n.keys())if(e!==_&&t.startsWith(e))return W(n.get(e),t.slice(e.length))},$=(n,t)=>{const e=t.length;t:for(let s=0;n&&s<e;){for(const o of n.keys())if(o!==_&&t[s]===o[0]){const r=Math.min(e-s,o.length);let c=1;for(;c<r&&t[s+c]===o[c];)++c;const u=n.get(o);if(c===o.length)n=u;else{const d=new Map;d.set(o.slice(c),u),n.set(t.slice(s,s+c),d),n.delete(o),n=d}s+=c;continue t}const i=new Map;return n.set(t.slice(s),i),i}return n},zt=(n,t)=>{const[e,s]=O(n,t);if(e!==void 0){if(e.delete(_),e.size===0)at(s);else if(e.size===1){const[i,o]=e.entries().next().value;lt(s,i,o)}}},at=n=>{if(n.length===0)return;const[t,e]=H(n);if(t.delete(e),t.size===0)at(n.slice(0,-1));else if(t.size===1){const[s,i]=t.entries().next().value;s!==_&&lt(n.slice(0,-1),s,i)}},lt=(n,t,e)=>{if(n.length===0)return;const[s,i]=H(n);s.set(i+t,e),s.delete(i)},H=n=>n[n.length-1],K="or",ht="and",It="and_not";class I{constructor(t){if(t?.fields==null)throw new Error('MiniSearch: option "fields" must be provided');const e=t.autoVacuum==null||t.autoVacuum===!0?j:t.autoVacuum;this._options={...P,...t,autoVacuum:e,searchOptions:{...et,...t.searchOptions||{}},autoSuggestOptions:{...Mt,...t.autoSuggestOptions||{}}},this._index=new b,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=Q,this.addFields(this._options.fields)}add(t){const{extractField:e,tokenize:s,processTerm:i,fields:o,idField:r}=this._options,c=e(t,r);if(c==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);if(this._idToShortId.has(c))throw new Error(`MiniSearch: duplicate ID ${c}`);const u=this.addDocumentId(c);this.saveStoredFields(u,t);for(const d of o){const a=e(t,d);if(a==null)continue;const l=s(a.toString(),d),h=this._fieldIds[d],m=new Set(l).size;this.addFieldLength(u,h,this._documentCount-1,m);for(const g of l){const f=i(g,d);if(Array.isArray(f))for(const p of f)this.addTerm(h,u,p);else f&&this.addTerm(h,u,f)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:s=10}=e,i={chunk:[],promise:Promise.resolve()},{chunk:o,promise:r}=t.reduce(({chunk:c,promise:u},d,a)=>(c.push(d),(a+1)%s===0?{chunk:[],promise:u.then(()=>new Promise(l=>setTimeout(l,0))).then(()=>this.addAll(c))}:{chunk:c,promise:u}),i);return r.then(()=>this.addAll(o))}remove(t){const{tokenize:e,processTerm:s,extractField:i,fields:o,idField:r}=this._options,c=i(t,r);if(c==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);const u=this._idToShortId.get(c);if(u==null)throw new Error(`MiniSearch: cannot remove document with ID ${c}: it is not in the index`);for(const d of o){const a=i(t,d);if(a==null)continue;const l=e(a.toString(),d),h=this._fieldIds[d],m=new Set(l).size;this.removeFieldLength(u,h,this._documentCount,m);for(const g of l){const f=s(g,d);if(Array.isArray(f))for(const p of f)this.removeTerm(h,u,p);else f&&this.removeTerm(h,u,f)}}this._storedFields.delete(u),this._documentIds.delete(u),this._idToShortId.delete(c),this._fieldLength.delete(u),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new b,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(e==null)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach((s,i)=>{this.removeFieldLength(e,i,this._documentCount,s)}),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;const{minDirtFactor:t,minDirtCount:e,batchSize:s,batchWait:i}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:i},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const s of t)this.discard(s)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:s}=this._options,i=s(t,e);this.discard(i),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(()=>{const s=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=Q,this.performVacuuming(t,s)}),this._enqueuedVacuum)):this.vacuumConditionsMet(e)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}async performVacuuming(t,e){const s=this._dirtCount;if(this.vacuumConditionsMet(e)){const i=t.batchSize||B.batchSize,o=t.batchWait||B.batchWait;let r=1;for(const[c,u]of this._index){for(const[d,a]of u)for(const[l]of a)this._documentIds.has(l)||(a.size<=1?u.delete(d):a.delete(l));this._index.get(c).size===0&&this._index.delete(c),r%i===0&&await new Promise(d=>setTimeout(d,o)),r+=1}this._dirtCount-=s}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(t){if(t==null)return!0;let{minDirtCount:e,minDirtFactor:s}=t;return e=e||j.minDirtCount,s=s||j.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=s}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(e!=null)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:s}=this._options,i={...s,...e},o=this.executeQuery(t,e),r=[];for(const[c,{score:u,terms:d,match:a}]of o){const l=d.length||1,h={id:this._documentIds.get(c),score:u*l,terms:Object.keys(a),queryTerms:d,match:a};Object.assign(h,this._storedFields.get(c)),(i.filter==null||i.filter(h))&&r.push(h)}return t===I.wildcard&&i.boostDocument==null||r.sort(nt),r}autoSuggest(t,e={}){e={...this._options.autoSuggestOptions,...e};const s=new Map;for(const{score:o,terms:r}of this.search(t,e)){const c=r.join(" "),u=s.get(c);u!=null?(u.score+=o,u.count+=1):s.set(c,{score:o,terms:r,count:1})}const i=[];for(const[o,{score:r,terms:c,count:u}]of s)i.push({suggestion:o,terms:c,score:r/u});return i.sort(nt),i}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static async loadJSONAsync(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(t),e)}static getDefault(t){if(P.hasOwnProperty(t))return N(P,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:s,documentIds:i,fieldLength:o,storedFields:r,serializationVersion:c}=t,u=this.instantiateMiniSearch(t,e);u._documentIds=T(i),u._fieldLength=T(o),u._storedFields=T(r);for(const[d,a]of u._documentIds)u._idToShortId.set(a,d);for(const[d,a]of s){const l=new Map;for(const h of Object.keys(a)){let m=a[h];c===1&&(m=m.ds),l.set(parseInt(h,10),T(m))}u._index.set(d,l)}return u}static async loadJSAsync(t,e){const{index:s,documentIds:i,fieldLength:o,storedFields:r,serializationVersion:c}=t,u=this.instantiateMiniSearch(t,e);u._documentIds=await V(i),u._fieldLength=await V(o),u._storedFields=await V(r);for(const[a,l]of u._documentIds)u._idToShortId.set(l,a);let d=0;for(const[a,l]of s){const h=new Map;for(const m of Object.keys(l)){let g=l[m];c===1&&(g=g.ds),h.set(parseInt(m,10),await V(g))}++d%1e3===0&&await ft(0),u._index.set(a,h)}return u}static instantiateMiniSearch(t,e){const{documentCount:s,nextId:i,fieldIds:o,averageFieldLength:r,dirtCount:c,serializationVersion:u}=t;if(u!==1&&u!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const d=new I(e);return d._documentCount=s,d._nextId=i,d._idToShortId=new Map,d._fieldIds=o,d._avgFieldLength=r,d._dirtCount=c||0,d._index=new b,d}executeQuery(t,e={}){if(t===I.wildcard)return this.executeWildcardQuery(e);if(typeof t!="string"){const h={...e,...t,queries:void 0},m=t.queries.map(g=>this.executeQuery(g,h));return this.combineResults(m,h.combineWith)}const{tokenize:s,processTerm:i,searchOptions:o}=this._options,r={tokenize:s,processTerm:i,...o,...e},{tokenize:c,processTerm:u}=r,l=c(t).flatMap(h=>u(h)).filter(h=>!!h).map(kt(r)).map(h=>this.executeQuerySpec(h,r));return this.combineResults(l,r.combineWith)}executeQuerySpec(t,e){const s={...this._options.searchOptions,...e},i=(s.fields||this._options.fields).reduce((f,p)=>({...f,[p]:N(s.boost,p)||1}),{}),{boostDocument:o,weights:r,maxFuzzy:c,bm25:u}=s,{fuzzy:d,prefix:a}={...et.weights,...r},l=this._index.get(t.term),h=this.termResults(t.term,t.term,1,t.termBoost,l,i,o,u);let m,g;if(t.prefix&&(m=this._index.atPrefix(t.term)),t.fuzzy){const f=t.fuzzy===!0?.2:t.fuzzy,p=f<1?Math.min(c,Math.round(t.term.length*f)):f;p&&(g=this._index.fuzzyGet(t.term,p))}if(m)for(const[f,p]of m){const y=f.length-t.term.length;if(!y)continue;g?.delete(f);const w=a*f.length/(f.length+.3*y);this.termResults(t.term,f,w,t.termBoost,p,i,o,u,h)}if(g)for(const f of g.keys()){const[p,y]=g.get(f);if(!y)continue;const w=d*f.length/(f.length+y);this.termResults(t.term,f,w,t.termBoost,p,i,o,u,h)}return h}executeWildcardQuery(t){const e=new Map,s={...this._options.searchOptions,...t};for(const[i,o]of this._documentIds){const r=s.boostDocument?s.boostDocument(o,"",this._storedFields.get(i)):1;e.set(i,{score:r,terms:[],match:{}})}return e}combineResults(t,e=K){if(t.length===0)return new Map;const s=e.toLowerCase(),i=Ct[s];if(!i)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(i)||new Map}toJSON(){const t=[];for(const[e,s]of this._index){const i={};for(const[o,r]of s)i[o]=Object.fromEntries(r);t.push([e,i])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,s,i,o,r,c,u,d=new Map){if(o==null)return d;for(const a of Object.keys(r)){const l=r[a],h=this._fieldIds[a],m=o.get(h);if(m==null)continue;let g=m.size;const f=this._avgFieldLength[h];for(const p of m.keys()){if(!this._documentIds.has(p)){this.removeTerm(h,p,e),g-=1;continue}const y=c?c(this._documentIds.get(p),e,this._storedFields.get(p)):1;if(!y)continue;const w=m.get(p),A=this._fieldLength.get(p)[h],D=Lt(w,g,this._documentCount,A,f,u),M=s*i*l*y*D,E=d.get(p);if(E){E.score+=M,Tt(E.terms,t);const L=N(E.match,e);L?L.push(a):E.match[e]=[a]}else d.set(p,{score:M,terms:[t],match:{[e]:[a]}})}}return d}addTerm(t,e,s){const i=this._index.fetch(s,it);let o=i.get(t);if(o==null)o=new Map,o.set(e,1),i.set(t,o);else{const r=o.get(e);o.set(e,(r||0)+1)}}removeTerm(t,e,s){if(!this._index.has(s)){this.warnDocumentChanged(e,t,s);return}const i=this._index.fetch(s,it),o=i.get(t);o==null||o.get(e)==null?this.warnDocumentChanged(e,t,s):o.get(e)<=1?o.size<=1?i.delete(t):o.delete(e):o.set(e,o.get(e)-1),this._index.get(s).size===0&&this._index.delete(s)}warnDocumentChanged(t,e,s){for(const i of Object.keys(this._fieldIds))if(this._fieldIds[i]===e){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${i}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,s,i){let o=this._fieldLength.get(t);o==null&&this._fieldLength.set(t,o=[]),o[e]=i;const c=(this._avgFieldLength[e]||0)*s+i;this._avgFieldLength[e]=c/(s+1)}removeFieldLength(t,e,s,i){if(s===1){this._avgFieldLength[e]=0;return}const o=this._avgFieldLength[e]*s-i;this._avgFieldLength[e]=o/(s-1)}saveStoredFields(t,e){const{storeFields:s,extractField:i}=this._options;if(s==null||s.length===0)return;let o=this._storedFields.get(t);o==null&&this._storedFields.set(t,o={});for(const r of s){const c=i(e,r);c!==void 0&&(o[r]=c)}}}I.wildcard=Symbol("*");const N=(n,t)=>Object.prototype.hasOwnProperty.call(n,t)?n[t]:void 0,Ct={[K]:(n,t)=>{for(const e of t.keys()){const s=n.get(e);if(s==null)n.set(e,t.get(e));else{const{score:i,terms:o,match:r}=t.get(e);s.score=s.score+i,s.match=Object.assign(s.match,r),st(s.terms,o)}}return n},[ht]:(n,t)=>{const e=new Map;for(const s of t.keys()){const i=n.get(s);if(i==null)continue;const{score:o,terms:r,match:c}=t.get(s);st(i.terms,r),e.set(s,{score:i.score+o,terms:i.terms,match:Object.assign(i.match,c)})}return e},[It]:(n,t)=>{for(const e of t.keys())n.delete(e);return n}},Ft={k:1.2,b:.7,d:.5},Lt=(n,t,e,s,i,o)=>{const{k:r,b:c,d:u}=o;return Math.log(1+(e-t+.5)/(t+.5))*(u+n*(r+1)/(n+r*(1-c+c*s/i)))},kt=n=>(t,e,s)=>{const i=typeof n.fuzzy=="function"?n.fuzzy(t,e,s):n.fuzzy||!1,o=typeof n.prefix=="function"?n.prefix(t,e,s):n.prefix===!0,r=typeof n.boostTerm=="function"?n.boostTerm(t,e,s):1;return{term:t,fuzzy:i,prefix:o,termBoost:r}},P={idField:"id",extractField:(n,t)=>n[t],tokenize:n=>n.split(Vt),processTerm:n=>n.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(n,t)=>{typeof console?.[n]=="function"&&console[n](t)},autoVacuum:!0},et={combineWith:K,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:Ft},Mt={combineWith:ht,prefix:(n,t,e)=>t===e.length-1},B={batchSize:1e3,batchWait:10},Q={minDirtFactor:.1,minDirtCount:20},j={...B,...Q},Tt=(n,t)=>{n.includes(t)||n.push(t)},st=(n,t)=>{for(const e of t)n.includes(e)||n.push(e)},nt=({score:n},{score:t})=>t-n,it=()=>new Map,T=n=>{const t=new Map;for(const e of Object.keys(n))t.set(parseInt(e,10),n[e]);return t},V=async n=>{const t=new Map;let e=0;for(const s of Object.keys(n))t.set(parseInt(s,10),n[s]),++e%1e3===0&&await ft(0);return t},ft=n=>new Promise(t=>setTimeout(t,n)),Vt=/[\n\r\p{Z}\p{P}]+/u,Ot=C(document.querySelector(".content")),At=C(document.querySelector(".search")),Dt=C(document.querySelector(".search__form")),S=C(document.querySelector(".search__input")),z=C(document.querySelector(".search__shortcut")),v=C(document.querySelector(".search__results")),Rt=C(document.querySelector(".search__resetbutton")),mt=navigator.platform.toUpperCase().indexOf("MAC")>=0,$t=mt?"Cmd":"Ctrl",gt=yt,Y=`${$t}+${gt}`,Z="ESC";z.textContent=Y;function k(){v.innerHTML="",S.value="",rt({[J]:null}),x("hide")}function G(n){n==="focus"&&(z.textContent=Y,z.title="Suchfeld fokussieren"),n==="clear"&&(z.textContent=Z,z.title="Suchtext löschen")}function x(n){n==="show"&&v.removeAttribute("aria-hidden"),n==="hide"&&v.setAttribute("aria-hidden",String(!0))}function Nt(n){const t={};return n.terms.forEach(e=>{const s=t.text||n.text,i=new RegExp(`(${e})`,"gi");t.text=s.replace(i,"<mark>$1</mark>")}),t}function ot(n){{const t=/-[a-zA-Z0-9]+_[a-zA-Z0-9]+\./;return n.replace(t,".")}}function Pt(n){const t=n.split("/").reverse()[0];return t?t.includes("?")?ot(t.split("?")[0]):ot(t):null}function q(n,t){return t?(typeof t=="string"&&(t=[t]),[...n?[n]:[],...t.filter(e=>e)].join(" <br> ")):n}const pt=new Map;pt.set("picture","bild");function jt(){const n=["ul","ol"];return[...Ot.children].map(e=>n.includes(e.tagName.toLowerCase())?[...e.children]:e).flat().map(e=>{let s=e.tagName.toLowerCase(),i,r=(e.innerText||e.textContent)?.trim()??null;if(s==="figure"){const c=e.querySelector("figcaption")?.innerText;r=c??r;const u=e.querySelector("picture");if(u){r="",s="picture";const a=u.querySelector("img");if(a?.src){const l=Pt(decodeURIComponent(a.src));l&&(r=q(r,`[${l}]`))}r=q(r,[a?.title||a?.alt])}const d=e.querySelector("lite-youtube");if(d){s="video",i="youtube";const a=d.querySelector("button")?.title.replace("Abspielen: ",""),l=d.getAttribute("videoid");r=a||l?`[YouTube Video: ${a||l}]`:"[YouTube Video]",r=q(r,c)}}return i=i??pt.get(s),{text:r,type:s,alias:i,el:e}}).filter(e=>e.text?.trim().length)}const U=new I({fields:["text","type","alias"],storeFields:["text","type"],searchOptions:{prefix:!0,processTerm:I.getDefault("processTerm"),fuzzy:.2,weights:{prefix:.5,fuzzy:.1},combineWith:"AND"}}),_t=new Map;function wt(){if(U.documentCount>0)return;let n=1;const t=jt().map(({el:e,...s})=>(n++,_t.set(n,e),{id:n,...s}));U.addAll(t)}function St(n){if(n==null)return null;if(n==="")return"";const t=n.trim();return t.length===0?null:t}function X(n){const t=St(n);if(t==null)return;if(t===""){k();return}rt({[J]:t}),v.innerHTML="";const e=U.search(t).map(l=>({...l,highlights:Nt(l)}));if(x("show"),e.length===0){const l=document.createElement("p");l.classList.add("search__info"),l.innerHTML=`Keine Suchergebnisse für <span class="search__query">"${t}"</span>`,v.append(l);return}const s=document.createElement("ul");s.classList.add("search__list","scrollbar"),e.forEach(l=>{const h=document.createElement("li"),m=document.createElement("button");m.classList.add("search__item");const g=l.highlights.text;m.innerHTML=g.replaceAll("<code>","").replaceAll("</code>",""),m.title="zu Suchergebnis springen",m.addEventListener("click",()=>{const f=_t.get(l.id);if(!f){console.error(`Unable to find clicked item (id: ${l.id})`),x("hide");return}f.scrollIntoView({block:"center",inline:"center"}),bt(f),x("hide"),k()}),h.append(m),s.append(h)});const i=document.createElement("header");i.classList.add("search__header"),v.prepend(i);const o=document.createElement("p");o.classList.add("search__count");const r=s.childElementCount,c=r>1||r===0?"Suchergebnisse":"Suchergebnis";o.innerHTML=`${r} ${c} für <span class="search__query">"${t}"</span>`,i.append(o);const u=document.createElement("button");u.classList.add("search__results-closebutton"),u.title=`${c} verbergen`,u.ariaLabel=`${c} verbergen`,u.addEventListener("click",()=>x("hide"));const d=document.createElementNS("http://www.w3.org/2000/svg","svg");d.classList.add("icon","search__results-icon");const a=document.createElementNS("http://www.w3.org/2000/svg","use");a.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#close"),d.appendChild(a),u.append(d),i.append(u),v.append(s)}function qt(){const n=new URLSearchParams(window.location.search).get(J);n&&(wt(),S.value=n,X(n))}qt();vt(At,()=>x("hide"));Dt.addEventListener("submit",n=>{n.preventDefault(),X(S.value),v.focus()});S.addEventListener("focus",()=>{wt(),!!St(S.value)&&x("show")});S.addEventListener("focusin",()=>G("clear"));S.addEventListener("focusout",n=>{n.relatedTarget?.textContent===Z||G("focus")});S.addEventListener("input",()=>X(S.value));Rt.addEventListener("click",()=>k());z.addEventListener("click",()=>{const n=z.textContent?.trim();n===Y&&S.focus(),n===Z&&(k(),G("focus"))});document.addEventListener("keydown",n=>{const t=mt?n.metaKey:n.ctrlKey;if(!tt()&&t&&n.key.toLowerCase()===gt.toLowerCase()&&(n.preventDefault(),S.focus()),tt()&&n.key==="Escape"){n.preventDefault();const e=document.activeElement;k(),e.blur()}n.key==="Escape"&&v.contains(document.activeElement)&&x("hide")});
